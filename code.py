# -*- coding: utf-8 -*-
"""code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17KJST9KVjBrOpIe493mcH3y6J9LhJL73
"""

import networkx as nx
import matplotlib.pyplot as plt

# Müzik tercihleri verileri
music_preferences ={
    "zeynep": ["pop","rock"],
    "ecem": ["rap","pop"],
    "furkan": ["rap", "arabesk"],
    "nisa": ["pop","rap","rock"],
    "rüştü": ["arabesk", "rap"],
    "başak": ["rock","pop","arabesk"],
    "osman": ["arabesk"],
    "büşra": ["rock", "arabesk","pop"],
    "emine": ["pop"],
    "seren": ["arabesk","pop"],
    "elif": ["rap","pop"],
    "ceyda": ["rap"],
    "öznur": ["arabesk"],
    "emre": ["rap"],
    "ebru": ["rock"],
    "poyraz": ["rap"],
    "emirhan": ["arabesk"],
    "melisa": ["pop", "rap"],
    "savaş": ["klasik","rap"],
    "çağla": ["klasik"]
}

G = nx.Graph()

for person, genres in music_preferences.items():
    G.add_node(person, type='person')
    for genre in genres:
        G.add_node(genre, type='genre')
        G.add_edge(person, genre)

for person1 in music_preferences:
    for person2 in music_preferences:
        if person1 != person2:
            common_genres = set(music_preferences[person1]) & set(music_preferences[person2])
            if common_genres:
                G.add_edge(person1, person2, common_genres=common_genres)

pos = nx.spring_layout(G, seed=42)

person_nodes = [node for node, attr in G.nodes(data=True) if attr['type'] == 'person']
genre_nodes = [node for node, attr in G.nodes(data=True) if attr['type'] == 'genre']

plt.figure(figsize=(20,12))

nx.draw_networkx_nodes(G, pos, nodelist=person_nodes, node_color='darkblue', node_size=1000, label='People')
nx.draw_networkx_nodes(G, pos, nodelist=genre_nodes, node_color='lightblue', node_size=1000, label='Genres')

nx.draw_networkx_edges(G, pos, edge_color='black', width=0.75, alpha=0.5)

labels = {node: node for node in G.nodes()}
nx.draw_networkx_labels(G, pos, labels, font_size=10, font_color='white', font_weight='bold')

for edge in G.edges(data=True):
    common_genres = edge[2].get('common_genres', [])
    if common_genres:
        common_genres_str = ', '.join(common_genres)


plt.title("Music Taste Network")
plt.legend()
plt.show()

from networkx.algorithms.community import k_clique_communities

k = 3
cliques = list(k_clique_communities(G, k))

for i, clique in enumerate(cliques, 1):
    print(f"Klik {i}: {', '.join(clique)}")

#pathsim değerleri için
def calculate_path_similarity(graph, node1, node2):
    try:
        shortest_path_length = nx.shortest_path_length(graph, source=node1, target=node2)
        path_similarity = 1 / (1 + shortest_path_length)
        return path_similarity
    except nx.NetworkXNoPath:
        return 0

path_similarity_dict = {}

for person1 in music_preferences:
    for person2 in music_preferences:
        if person1 != person2 and (person2, person1) not in path_similarity_dict:
            path_similarity = calculate_path_similarity(G, person1, person2)
            path_similarity_dict[(person1, person2)] = path_similarity

for pair, similarity in path_similarity_dict.items():
    print(f"{pair[0]} ve {pair[1]}: {similarity:.2f}")

print(G.nodes)

edge_count = G.number_of_edges()

print("Kenar sayısı:", edge_count)

# Düğüm sayısını bulma
node_count = G.number_of_nodes()

print("Düğüm sayısı:", node_count)

connected_components_count = nx.number_connected_components(G)

print("Bağlı bileşen sayısı:", connected_components_count)

print(G.degree())  # (node, degree)

nx.draw(G, node_size=[G.degree(i)*100 for i in G.nodes], with_labels=True)

degree_sequence = sorted((d for (n,d) in G.degree()), reverse=True)
dmax=max(degree_sequence)
print(dmax)

print(degree_sequence)

import numpy as np

#we need the unique values of the degree and
#how many times a node obtains this degree.
unique_degree_sequence = np.unique(degree_sequence, return_counts=True)
print(unique_degree_sequence)
#the first array represents the unique values
#the second array tells us  the count for each of the corresponding   values

#plotting degree histogram
plt.bar(unique_degree_sequence[0],unique_degree_sequence[1])
plt.title("Degree histogram")
plt.xlabel("Degree")
plt.ylabel("#of Nodes")

plt.show()

probabilities=[d/sum(unique_degree_sequence[1]) for d in unique_degree_sequence[1]]
print(probabilities)
print(sum(probabilities)) #derece dağılımlarının ortalamasını buluyoruz.

one_hop_neighbors = nx.ego_graph(G,"ecem", radius=1,center= True, undirected=True)
nx.draw(one_hop_neighbors, with_labels=True)

nodes = list(one_hop_neighbors.nodes())
nodes.remove("ecem")

one_hop_neighbors_subgraph = G.subgraph(nodes)
nx.draw(one_hop_neighbors_subgraph, with_labels=True)

average_clustering_coefficient = nx.average_clustering(G)
print("Ortalama Kümelenme Katsayısı:", average_clustering_coefficient)

clustering_coefficients = nx.clustering(G)
for node, coefficient in clustering_coefficients.items():
    print(f"{node}: Kümelenme Katsayısı = {coefficient}")

print(nx.clustering(G))

nx.draw(G, node_size=[nx.clustering(G,i)*1000 for i in G.nodes], with_labels=True)

deg_0=G.degree("zeynep")
n= G.number_of_nodes()
print(deg_0,n-1)

print(nx.degree_centrality(G)) #DERECE MERKEZİLİĞİ

N = len(G.nodes)
nodes = G.nodes

sum_degree_0 = 0
for n in nodes:
  if n != "ecem":
    distance = nx.shortest_path_length(G, source="ecem", target=n)
    sum_degree_0 += distance

print(N, sum_degree_0)

"""25 bizim düğüm sayımız, 32 ise ecemin diğer yollara olan uzaklığı

"""

closenessCentrality_0= (N-1)/sum_degree_0
print(closenessCentrality_0) #ORTALAMA YOL UZUNLUĞU

print(nx.closeness_centrality(G)) #YAKINLIK MERKEZİLİĞİ

nx.draw(G, node_size=[i*1000 for i in nx.closeness_centrality(G).values()], with_labels=True)
# neredeyse düğümlerin yakınlık merkeziliği açısından benzer bir değer aldığını görüyoruz.
#Bunun nedeni grafiğin kendi içinde bağlantılı bir bileşen olmasıdır
#ve tüm düğümlere temel olarak diğer tüm düğümlerden ulaşılabilir ve
#eğer grafiğin bağlantıları güçlüyse, yani düğümlerin çoğu diğer düğümlerin çoğuna bağlıysa
#veya doğrudan bağlı değil ama erişilebilir olabilir.
#Yani, yakınlık merkeziliğinin tüm düğümler için neredeyse benzer olmasının nedeni budur.

#betweenness merkeziliği temel olarak bize belirli bir düğümün kaç kez geçilmesi gerektiğini söyler
#bir düğümden diğer düğüme geçmek için.
#Yani, belirli bir düğümün diğer iki düğüm arasındaki en kısa yol arasına kaç kez girdiği
print(nx.betweenness_centrality(G))

nx.draw(G, node_size= [i*5000 for i in nx.betweenness_centrality(G).values()], with_labels=True)
#YANİ BURADA SAVAŞI AĞDAN ÇIKARIRSAK ÇAĞLA VE KLASİK DÜĞÜMÜNÜN AĞ BAĞLANTISI KESİLİR.

print(nx.pagerank(G))

nx.draw(G, node_size= [i*5000 for i in nx.pagerank(G).values()], with_labels=True)

"""ÜSTTEKİ DÜĞÜMDE PAGERANK EN BÜYÜK OLAN NİSADIR."""

print([i for i in nx.shortest_path_length(G)])

print(nx.diameter(G)) #ÇAP

print(nx.density(G)) #AĞIN YOĞUNLUĞU

#we get a connected component  of 1 that is each node is reachable by all the other nodes
print(nx.number_connected_components(G))

commonNeighbours= sorted(nx.common_neighbors(G,"zeynep","savaş"))
print(commonNeighbours)

len(commonNeighbours)

jaccardCoefficient = nx.jaccard_coefficient(G, [("zeynep", "savaş")])

for u, v, p in jaccardCoefficient:
    print(f"({u}, {v}) -> {p:.8f}")